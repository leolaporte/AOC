#lang racket
;  AOC 2021
; Leo Laporte
; 
; --- Day 5: Hydrothermal Venture ---
; 
; You come across a field of hydrothermal vents on the ocean floor! These vents constantly
; produce large, opaque clouds, so it would be best to avoid them if possible.
; 
; They tend to form in lines; the submarine helpfully produces a list of nearby lines of vents
; (your puzzle input) for you to review. For example:
; 
; 0,9 -> 5,9
; 8,0 -> 0,8
; 9,4 -> 3,4
; 2,2 -> 2,1
; 7,0 -> 7,4
; 6,4 -> 2,0
; 0,9 -> 2,9
; 3,4 -> 1,4
; 0,0 -> 8,8
; 5,5 -> 8,2
; 
; Each line of vents is given as a line segment in the format x1,y1 -> x2,y2 where x1,y1
; are the coordinates of one end the line segment and x2,y2 are the coordinates of the other end.
; These line segments include the points at both ends. In other words:
; 
;     An entry like 1,1 -> 1,3 covers points 1,1, 1,2, and 1,3.
;     An entry like 9,7 -> 7,7 covers points 9,7, 8,7, and 7,7.
; 
; For now, only consider horizontal and vertical lines: lines where either x1 = x2 or y1 = y2.
; 
; So, the horizontal and vertical lines from the above list would produce the following diagram:
; 
; .......1..
; ..1....1..
; ..1....1..
; .......1..
; .112111211
; ..........
; ..........
; ..........
; ..........
; 222111....
; 
; In this diagram, the top left corner is 0,0 and the bottom right corner is 9,9. Each position
; is shown as the number of lines which cover that point or . if no line covers that point.
; The top-left pair of 1s, for example, comes from 2,2 -> 2,1; the very bottom row is formed
; by the overlapping lines 0,9 -> 5,9 and 0,9 -> 2,9.
; 
; To avoid the most dangerous areas, you need to determine the number of points where at
; least two lines overlap. In the above example, this is anywhere in the diagram with a 2
; or larger - a total of 5 points.
; 
; Consider only horizontal and vertical lines. At how many points do at least two lines overlap?


(require racket/file threading rackunit)

;; Problem input from adventofcode.com
(define day5data (file->string "input5.txt"))

(define input-points (~> day5data ; turn the given data into a list of lines (x1 y1 x2 y2)
                         (string-split _ "\n")
                         (map
                          (位 (x) (regexp-match #px"(\\d+),(\\d+).+ (\\d+),(\\d+)" x)) _)
                         (map (位 (x) (rest x)) _)
                         (map (位 (x) (map string->number x)) _)))

;; Provided test data (in same format as above)
(define sample-points (list '(0 9 5 9) '(8 0 0 8) '(9 4 3 4) '(2 2 2 1) '(7 0 7 4)
                            '(6 4 2 0) '(0 9 2 9) '(3 4 1 4) '(0 0 8 8) '(5 5 8 2)))

;; NOTES
;; This looks pretty easy. Too easy...
;; Convert the input to a list of lines, each line stored as four points (x1 y1 x2 y2)
;; Convert each line into the set of points it touches: ((x1,y1)..(x2,y2))
;; for each point in the set increment that point's entry in a hash table, if a point
;; is not in the hash add it, count total number of points with more than one entry
;;
;; Oh and it WAS too easy... there are two additional tricky points
;; 1) the provided end points can be right->left as well as left->right, and bottom->top
;; as well as top->bottom (make sure to account for those)
;; 2) some of the provided lines might be diagonals(!) and for part 1 we needn't consider
;; them.
;;
;; Just in case we need to pay attention to diagonals in part two, I need to write the
;; point generator to handle both these cases. For now, I can eliminate the diagonals

(define (count-multipoint-entries hsh)
  (length (filter (位 (x) (> x 1)) (hash-values hsh))))

(define (make-point-hash hsh all-points)
  (cond [(empty? all-points) hsh]
        [else
         (increment-points hsh (make-point-list (first all-points)))
         (make-point-hash hsh (rest all-points))]))

(define (make-point-list end-points)
  (let ([x1 (first end-points)]
        [y1 (second end-points)]
        [x2 (third end-points)]
        [y2 (fourth end-points)])
    (for*/list ([x (points-to-from x1 x2)]
                [y (points-to-from y1 y2)])
      (cons x y))))

(module+ test
  (check-equal? (make-point-list '(0 9 5 9))  ; horizontal
                (list '(0 . 9) '(1 . 9) '(2 . 9) '(3 . 9) '(4 . 9) '(5 . 9)))
  (check-equal? (make-point-list '(7 0 7 4))  ; vertical 
                (list '(7 . 0) '(7 . 1) '(7 . 2) '(7 . 3) '(7 . 4)))
  (check-equal? (make-point-list '(9 7 7 7))  ; right -> left
                (list '(7 . 7) '(8 . 7) '(9 . 7)))
    (check-equal? (make-point-list '(0 5 0 0))  ; bottom -> top
                '((0 . 0) (0 . 1) (0 . 2) (0 . 3) (0 . 4) (0 . 5))))

(define (points-to-from x y)
  "provides points in a line no matter in which direction it goes"
  (if (< x y)
      (stream->list (in-inclusive-range x y))
      (stream->list (in-inclusive-range y x))))

(define (increment-points hsh point-list)
  (cond [(equal? empty point-list) hsh]
        [else (increment-point hsh (first point-list))
              (increment-points hsh (rest point-list))]))

(define (increment-point hsh pt)
  (if (hash-has-key? hsh pt)
      (hash-update! hsh pt add1)      
      (hash-update! hsh pt add1 0)))

;; (list-of Natural) -> boolean
;; given four points representing the beginning and end of a line
;; return true if that line is horizontal or vertical (i.e. not diagonal)
(define (straight-line? points)
  (let ([x1 (first points)]
        [y1 (second points)]
        [x2 (third points)]
        [y2 (fourth points)])
    (or (= x1 x2) (= y1 y2))))

(module+ test
  (check-equal? (straight-line? '(8 0 0 8)) #f)
  (check-equal? (straight-line? '(0 9 5 9)) #t))

(define (day5.1 input)
  (~> input
      (filter straight-line? _) ; only count straight lines
      (make-point-hash (make-hash) _)
      (count-multipoint-entries _)))

(module+ test
  (check-equal? (day5.1 sample-points) 5))

(time (printf "2021 AOC Problem 5.1 = ~a\n" (day5.1 input-points)))

;  
; 


;(define (day5.2 data) 0) ; stub
;
;(module+ test
;  (check-equal? (day5.2 sample-points) 0))
;
;(time (printf "2021 AOC Problem 5.2 = ~a\n" (day5.2 input-points)))

; Time to solve, in milliseconds, on a 2021 M1 Pro MacBook Pro 14" with 16GB RAM

; Real world timing

