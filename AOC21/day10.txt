#lang racket
;  AOC 2021
; Leo Laporte
; 
; --- Day 10: Syntax Scoring ---
; 
; You ask the submarine to determine the best route out of the deep-sea cave,
; but it only replies:
; 
; Syntax error in navigation subsystem on line: all of them
; All of them?! The damage is worse than you thought. You bring up a copy of
; the navigation subsystem (your puzzle input).
; 
; The navigation subsystem syntax is made of several lines containing chunks.
; There are one or more chunks on each line, and chunks contain zero or more
; other chunks. Adjacent chunks are not separated by any delimiter; if one
; chunk stops, the next chunk (if any) can immediately start. Every chunk
; must open and close with one of four legal pairs of matching characters:
; 
; If a chunk opens with (, it must close with ).
; If a chunk opens with [, it must close with ].
; If a chunk opens with {, it must close with }.
; If a chunk opens with <, it must close with >.
; 
; So, () is a legal chunk that contains no other chunks, as is []. More complex
; but valid chunks include ([]), {()()()}, <([{}])>, [<>({}){}[([])<>]], and
; even (((((((((()))))))))).
; 
; Some lines are incomplete, but others are corrupted. Find and discard the
; corrupted lines first.
; 
; A corrupted line is one where a chunk closes with the wrong character - that
; is, where the characters it opens and closes with do not form one of the four
; legal pairs listed above.
; 
; Examples of corrupted chunks include (], {()()()>, (((()))}, and <([]){()}[{}]).
; Such a chunk can appear anywhere within a line, and its presence causes the
; whole line to be considered corrupted.
; 
; For example, consider the following navigation subsystem:
; 
; [({(<(())[]>[[{[]{<()<>>
; [(()[<>])]({[<{<<[]>>(
; {([(<{}[<>[]}>{[]{[(<()>
; (((({<>}<{<{<>}{[]{[]{}
; [[<[([]))<([[{}[[()]]]
; [{[{({}]{}}([{[{{{}}([]
; {<[[]]>}<{[{[{[]{()[[[]
; [<(<(<(<{}))><([]([]()
; <{([([[(<>()){}]>(<<{{
; <{([{{}}[<[[[<>{}]]]>[]]
;         
; Some of the lines aren't corrupted, just incomplete; you can ignore these
; lines for now. The remaining five lines are corrupted:
; 
; {([(<{}[<>[]}>{[]{[(<()> - Expected ], but found } instead.
; [[<[([]))<([[{}[[()]]] - Expected ], but found ) instead.
; [{[{({}]{}}([{[{{{}}([] - Expected ), but found ] instead.
; [<(<(<(<{}))><([]([]() - Expected >, but found ) instead.
; <{([([[(<>()){}]>(<<{{ - Expected ], but found > instead.
;        
; Stop at the first incorrect closing character on each corrupted line.
; 
; Did you know that syntax checkers actually have contests to see who can
; get the high score for syntax errors in a file? It's true! To calculate
; the syntax error score for a line, take the first illegal character on
; the line and look it up in the following table:
; 
; ): 3 points.
; ]: 57 points.
; }: 1197 points.
; >: 25137 points.
; 
; In the above example, an illegal ) was found twice (2*3 = 6 points),
; an illegal ] was found once (57 points), an illegal } was found once
; (1197 points), and an illegal > was found once (25137 points). So,
; the total syntax error score for this file is 6+57+1197+25137 = 26397 points!
; 
; Find the first illegal character in each corrupted line of the navigation
; subsystem. What is the total syntax error score for those errors?


(require threading
         rackunit)

;; Problem input from adventofcode.com
(define problem-data (string-split (file->string "input10.txt") "\n"))

(define test-data
  (string-split "[({(<(())[]>[[{[]{<()<>>\n[(()[<>])]({[<{<<[]>>(\n{([(<{}[<>[]}>{[]{[(<()>\n(((({<>}<{<{<>}{[]{[]{}\n[[<[([]))<([[{}[[()]]]\n[{[{({}]{}}([{[{{{}}([]\n{<[[]]>}<{[{[{[]{()[[[]\n[<(<(<(<{}))><([]([]()\n<{([([[(<>()){}]>(<<{{\n<{([{{}}[<[[[<>{}]]]>[]]"
                "\n"))

;; NOTES:
;; to simplify an expression look for matching pairs () {} [] <> and eliminate them.
;; Once an expression cannot be simplified further you've found a bug or an incomlete
;; statement.
;; The incomplete statement will have no closing delimiters.
;; If statement is not incomplete it's bugged.
;; The first closing delimiter is the bug.

;; Regexp patterns
(define PAIRS (regexp "<>|\\[\\]|\\{\\}|\\(\\)")) ; matching opens and closes
(define CLOSES (regexp ">|\\]|\\}|\\)"))          ; the closing delimiters

;; String -> String
;; Removes matching pairs from string
(define (strip-pairs str)
  (let ([shrunk (regexp-replace* PAIRS str "")])       
    
    (cond [(false? (regexp-match PAIRS shrunk)) shrunk]  
          [else (strip-pairs shrunk)])))                 

;; String -> Natural
;; Given a string return the value of the first bug or 0 if no bugs
(define (bug-bounty str)
  (match (regexp-match CLOSES str)
    ['(")") 3]
    ['("]") 57]
    ['("}") 1197]
    ['(">") 25137]
    [#f 0]))

(module+ test
  (check-equal? (bug-bounty (strip-pairs "{([(<{}[<>[]}>{[]{[(<()>")) 1197)
  (check-equal? (bug-bounty (strip-pairs "[[<[([]))<([[{}[[()]]]")) 3)
  (check-equal? (bug-bounty (strip-pairs "[{[{({}]{}}([{[{{{}}([]")) 57)
  (check-equal? (bug-bounty (strip-pairs "[<(<(<(<{}))><([]([]()")) 3)
  (check-equal? (bug-bounty (strip-pairs "<{([([[(<>()){}]>(<<{{")) 25137) 
  (check-equal? (bug-bounty (strip-pairs "[({(<(())[]>[[{[]{<()<>>")) 0))

;; (list-of String) -> Natural
;; Given a list of navigation strings return the total bug-bounty for
;; strings with errors
(define (day10.1 input)
  (for/sum ([str (in-list input)])
    (bug-bounty (strip-pairs str))))

(module+ test
  (check-equal? (day10.1 test-data) 26397))

(time (printf "2021 AOC Problem 10.1 = ~a\n" (day10.1 problem-data)))

;  
; 


; (define (day10.2 data) 0) ; stub

;(module+ test
;  (check-equal? (day10.2 sample-data) 0))
;
;(time (printf "2021 AOC Problem 10.2 = ~a\n" (day10.2 day10data)))

; Time to solve, in milliseconds, on a 2021 M1 Pro MacBook Pro 14" with 16GB RAM

; Real world timing
