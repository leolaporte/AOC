#lang racket
;  AOC 2021
; Leo Laporte 3 Dec 2021
; 
; --- Day 3: Binary Diagnostic ---
; 
; The submarine has been making some odd creaking noises, so you ask it to produce a
; diagnostic report just in case.
; 
; The diagnostic report (your puzzle input) consists of a list of binary numbers
; which, when decoded properly, can tell you many useful things about the conditions
; of the submarine. The first parameter to check is the power consumption.
; 
; You need to use the binary numbers in the diagnostic report to generate two new
; binary numbers (called the gamma rate and the epsilon rate). The power consumption
; can then be found by multiplying the gamma rate by the epsilon rate.
; 
; Each bit in the gamma rate can be determined by finding the most common bit in
; the corresponding position of all numbers in the diagnostic report. For example,
; given the following diagnostic report:
; 
; 00100
; 11110
; 10110
; 10111
; 10101
; 01111
; 00111
; 11100
; 10000
; 11001
; 00010
; 01010
; 
; Considering only the first bit of each number, there are five 0 bits and seven 1 bits.
; Since the most common bit is 1, the first bit of the gamma rate is 1.
; 
; The most common second bit of the numbers in the diagnostic report is 0, so the second
; bit of the gamma rate is 0.
; 
; The most common value of the third, fourth, and fifth bits are 1, 1, and 0, respectively,
; and so the final three bits of the gamma rate are 110.
; 
; So, the gamma rate is the binary number 10110, or 22 in decimal.
; 
; The epsilon rate is calculated in a similar way; rather than use the most common bit,
; the least common bit from each position is used. So, the epsilon rate is 01001, or 9 in
; decimal. Multiplying the gamma rate (22) by the epsilon rate (9) produces the power
; consumption, 198.
; 
; Use the binary numbers in your diagnostic report to calculate the gamma rate and
; epsilon rate, then multiply them together. What is the power consumption of the submarine?
; (Be sure to represent your answer in decimal, not binary.)
; 
; 


(require racket/file rackunit)

;; Problem input from adventofcode.com
(define day3data (string-split (file->string "input3.txt") "\n"))

(define sample-data
  (list "00100" "11110" "10110" "10111" "10101" "01111" "00111" "11100" "10000" "11001" "00010" "01010"))

;; naive method
;; 1. add up each place of each number in the list of binary numbers 
;; 2. per place divide place total by 2, if greater than length of list, that place is 1, else 0
;; 3. multiply that number represented by all places (gamma) by its ones-complement (epsilon), result is solution
;; this is so heinous there must be a better way but I can't think of what it is

;; list-of string -> integer
;; given a list of strings of binary numbers produce the product of the gamma and epsilon
(define (day3.1 num-list)
  (let* ((num-entries (length num-list))  ; number of entries in the list
         (column-totals (add-columns (map string->list num-list))) ; add up the numbers in each column
         (sums (sum-row num-entries column-totals)) ; calc the gamma and epsilon '(gamma . epsilon)
         (gamma (car sums))
         (epsilon (cdr sums)))
    (* gamma epsilon)))
           
(module+ test
  (check-equal? (day3.1 sample-data) 198))
   
;; natural (list-of natural) -> (gamma . epsilon)
;; given a list of numbers, return the gamma and epsilon values
(define (sum-row len total-list)
  (let ([threshold (quotient len 2)]) ; if sum of digits > len/2 then there are more 1s than 0s
    (for/fold ([gamma null]       ; accumulators...
               [epsilon null]     ; ... fold builds lists of 1s and 0s
               #:result (cons (bin-list->decimal (reverse gamma)) (bin-list->decimal (reverse epsilon)))) 
              ([x (in-list total-list)])
      (if (> x threshold)
          (values (cons 1 gamma) (cons 0 epsilon))      
          (values (cons 0 gamma) (cons 1 epsilon))))))

(module+ test
  (check-equal? (sum-row 14 '(12 5 14 1)) '(10 . 5))
  (check-equal? (sum-row 12 '(7 5 8 7 5)) '(22 . 9)))  

;; (list-of 1 or 0) -> natural
;; turn list of binary digits into its decimal equivalent, eg. '(1 0 1 0) into 10
(define (bin-list->decimal lst)
  (local [(define (list->string l)
            (cond ((empty? l) "")
                  (else (string-append (number->string (first l)) (list->string (rest l))))))]
    (string->number (list->string lst) 2)))

(module+ test
  (check-equal? (bin-list->decimal '(1 0 1 0)) 10)
  (check-equal? (bin-list->decimal '(1 1 1 1)) (+ 1 2 4 8))
  (check-equal? (bin-list->decimal '(1 0 0 0)) 8))
            
;; natural (list-of (list-of bytes)) -> (list-of natural)
;; add up the numbers in each column of a list of byte-strings representing binary numbers
;; produces a list with a total for each column in the given numbers
(define (add-columns byte-list)
  (local [(define (recursive-add-columns entry-accum lst)
            (cond ((empty? lst) entry-accum)
                  (else  (recursive-add-columns
                          (add-entry (map char->number (first lst)) entry-accum) (rest lst)))))]
    (recursive-add-columns (make-list (length (first byte-list)) 0) byte-list)))

(module+ test
  (check-equal? (add-columns (map string->list sample-data)) (list 7 5 8 7 5)))

(define (add-entry entry entries)
  (for/list ([i (in-list entry)]
             [j (in-list entries)])
    (+ i j)))

(module+ test
  (check-equal? (add-entry '(0 0 0 0) (map char->number (string->list "1111"))) '(1 1 1 1))
  (check-equal? (add-entry '(1 1 1 1) (map char->number (string->list "1111"))) '(2 2 2 2))
  (check-equal? (add-entry '(9 9 9 9) (map char->number (string->list "1111"))) '(10 10 10 10)))

(define (char->number char)
  (- (char->integer char) (char->integer #\0) ))
             
(time (printf "2021 AOC Problem 3.1 = ~a\n" (day3.1 day3data)))

;  --- Part Two ---
; 


(define (day3.2 day3data) 0) ; stub

(module+ test
  (check-equal? (day3.2 day3data) 0))

; (time (printf "2021 AOC Problem 3.2 = ~a\n" (day3.2 day3data)))

; Time to solve, in milliseconds, on a 2021 M1 Pro MacBook Pro 14" with 16GB RAM

; Real world timing
